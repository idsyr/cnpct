#+title: Базовый курс C++ (MIPT, ILab). Lecture 13. Проектирование
#+author: idsyr

* Снова контексты и интерфейсы
** Контексты и интерфейсы
*** Интерфейс (C-style): matrix.h
#+begin_src C++
struct M;
M* create_diag(size_t);
M* prog(const M*, const M*);
double det(const *M);
void destroy(M*);
// ...
#+end_src
*** Контекст (C-style): matrix.c
#+begin_src C++
struct M {
    double *contents;
    size_t x, y;
}
#define Msz sizeof(M);
M* create_diag(size_t w) {
    M* ret = malloc(Msz);
// ... 
#+end_src
- forvard decl структуры мы делаем для того, чтобы не раскрывать существенных деталей

 
*** Интерфейс (C++ style): imatrix.h
#+begin_src C++
struct IM {
virtual IM& clone(const IM&);
virtual ~IM() = 0;
// ...
#+end_src
*** Контекст (C++ style): matrix.hpp
#+begin_src C++
template <typename T>
class M : public IM {
    T *contents;
    size_t x, y;
public:
    M(M& rhs);
    M& clone(const IM&) override;
// все реализации в том же файле
#+end_src
- _Контекст нам нужен чтобы сохранять инвариант_



** Базовые понятия
- Контекст инкапсулирует данные и охраняет инварианты
- Контекст реализует интерфейс (для типов в С++ через наследование интерфейса)
- Производный контекст расширяет базовый (для типов в С++ через наследование реализации)
- Если контексты это типы, производный контекст связан с базовым дополнительными отношениями (частное\общее, быть частью и подобными)
- Если несколько типов реализуют общий интерфейс, вызовы их методов через этот интерфейс полиморфны

* Проектирование
** Обсуждение: проектирование
- Проектирование сложной системы классов это человеческая деятельность
- Что является артефактом этой деятельности?(делаете пиражок в духовке - артефакт=пиражок)
- И правильный ответ: отношение
- Как можно было бы хотя бы частично формализовать этот процесс?
** Обсуждение: язык моделирования 
- Проектирование это моделирование отношений между типами
- В каких отношениях могут быть друг с другом классы в С++?
- Примеры отношений: "А наследует от B" или "C является полем в D"







* UML
** Отношения между классами и UML
- UML это специальный язык, который моделирует классы и отношения между классами (отношения будут далее)
- Класс в UML определяется через свое имя, поля и методы
- По традиции имя идет в первом квадрате, поля во втором, а методы в третьем
- Формат полей "поле: тип" (несколько контринтуитивно для С++)
- UML поддерживает также тонны других атрибутов, например шаблонные параметры
** Отношения между классами и UML
- Ассоциация: сущности каким то образом связаны друг с другом
- Генерализация: отношение частоное\общее (для С++ это открытое наследование)
- Композиция отзначает, что сущность B является частью сущности A. Связаны временем жизни - удаляем А -> удаляется и В
- Агрегация: сущность А владеет сущностью В, но кроме А у В может быть много владельцев
** Обсуждение
- UML это средство описания, которым можно описать любую систему, в том числе сколь угодно плохую
- Software имеет английский корень soft, означающий нечто, что легко изменять
- _Первый шаг к хорошему коду это легко изменяемый код_



* SOLID
классическая трактовка
- SRP - single responsibility principle
  - Каждый контекст должен иметь одну ответственность
- OCP - open-close principle
  - каждый контекст должен быть закрыт для изменения и открыт для расширения
- LSP - Liskov substitution principle
  - частный класс должен иметь возможность свободно заменять общий
- ISP - interface separation principle
  - Тип не должен зависеть от тех интерфейсов, которые он не использует
- DIP - dependency inversion principle
  - Высокоуровневые классы не должны зависеть от низкоуровневых


* Единственная ответственность
** Пример плохого проектирования (SRP)
- Пример с полигоном который сам себя рисует и сам сериализует, и в нем есть 3 причины поменяться и только первая законная:
  - Изменилось что то в геометрии: мы перешли на 2d вектор
  - Что то изменилось в классе Screen, который используется в методе draw
  - Что то изменилось в классе ByteStream, который используется в методе serialize 
- _"A class should have only one reason to change" (Robert C. Martin)_
- Можно использовать для вывода итераторы(begin(), end()), в итоге функции могут обращаться к элементам но не к состоянию полгиона
- "We want to design conponents that are self-contained: independent and with single well-defined purpose" (Andrew Hunt, David Thomas)

* Связность
- У хорошо спроектированной и плохо - одинаковые побочные эффекты получая одинаковые входные данные - в математике это называется экстенсионально равны
- Tom DeMarco & Timothy Lister - Peopleware 
** Гайдлайн: связность
- Ваши сущности должны быть внутренне связаны (cohesive) и внешне разделены
- Разделяйте все, что может быть разделено без создания жестких внешних связей. Пример: отделение алгоритмов от контейнеров
- "Cohesion is a measure of the strength of association of the elemets inside a module. A highly cohesive module is a collection od statements and data items that should be treated as a whole becaude they are so closely related." (Tom DeMarco)


* Принцип открытости и закрытости
- Ваш класс не должен нуждаться в модификации при необходимости расширения
- Класс экрана который хранит массив указателей на фигуры и знает как рисовать вектор и полигон и имеет интерфейс отрисовки фигуры. Как он поймет что конкретно рисовать?
- enum class Shape, в draw(const IFigure &) switch по типу 
- И если понадобится добавить отрисовку круга, понадобиться модификация
- Классический выход из положения - заменить switch на виртуальные функции. вектор и полигон знают как рисовать себя на экране
- Но ведь мы походили кругом - SRP. И полигон все таки должен знать как его рисовать или не должен?

* Инцидентные структуры данных
- Такие структуры данных в которых указатель на часть одной структуры торчит в часть другой структуры и потом заворачивается наоборот а потом еще заворачивается 
- Правило проектирование - отсутствие в коде таких структур

* Parent inversion
** Обсуждение
- Такое чувство, что OCP в таком наивном виде противоречит SRP
- Мы добавили виртуальную функцию draw в полинон, но мы несколькоми неслайдами раньше договрились этого _не делать_.
- "Inheritance is the base class of Evil" (Sean Parent)
- Динамический полиморфизм не должен быть частью интерфейса
** Модель и концепция 
- Пример в котором вектор и полигон становятся всего лишь возможными параметрами шаблона обьекта DrawableObject с интерфейсом IDrawable.
- В итоге соблюдается и SRP и OCP
- Когда конкретное уточнение выносится в шаблонный параметр - parent inversion
** Обсуждение
- Техники наподобие Parent Reversal(inversion) позволяют помирить OCP и SRP
- Теперь мы расширяем добавляя свободные функции, полиморфные, как множество перегрузки 
- Динамический полиморфизм при этом остается деталью реализации
- Шаблонный полиморфизм используется чтобы позволить обобщенное программирование



* Подстановка Лисков
** Пример плохого проектирования 
#+begin_src cpp
bool intersect(Polygon2D& l, Polygon2D& r);
class Polygon2D {
  std::vector<double> xcoord, ycoordl;
}
class Polygon3D : public Polygon2D {
  std::vector<double> xcoord;
}
#+end_src
- Более общие классы должны быть более общими и по составу и по поведению
#+begin_src cpp
class Polygon3D : public Polygon2D;
#+end_src
- Это читается так: трехмерный полигон может быть использован во всех контекстах, где нам нужен двумерный полигон. Если это некорректно, наследовать нельзя.
- Предусловаия алгоримтов не могут быть усилины производным классомл.
- Постусловаия алгоритмов не могут быть ослаблены производным классом
- Важной концепцией для LSP является ковариантность 

* Ковариантность к генерализации
** Ковариантность
- Мы говрим, что изменение типа ковариантно к генерализации, если выполняется условие
  - если А обобщает В, то А' обобщает В'
*** Указатели, ковариантность
- Собственно указатели воариантны к генерализации если трактовать A' = A*
#+begin_src cpp
class Rectangle : public Shape { /* ... */ }
void draw(Shape* shapes, size_t size);
Rectangle rects[5];
draw(rects, 5); // ok, Rectangle* is Shape*
#+end_src
*** Шаблоны, интервариантность
- При этом шаблоны вообще-то инвариантны к генерализации
#+begin_src cpp
class Rectangle : public Shape { /* ... */ }
void draw(std::vector<Shape> shapes);
std::vector<Rectangle> rects(5);
draw(rects); // fail, vector<Rectangle> is not vector<Shape>
#+end_src
** Обсуждение
- Можно поставить обратный вопрос: а почему, собственно, указатели инвариантны?
#+begin_src cpp
template <typename T> using Pointer = T*; // казалось бы
void draw(Pointer<Shape> shapes, size_t size);
Pointer<Rectangle> rects = new Rectangle[5];
draw(rects, 5); // ok, но чем Pointer<Rectangle> лучше чем  std::vector<Rectangle>?
#+end_src
- Подсказка: ковариантны только одинарные указатели
- Таким образом, ковариантность указателей и ссылок к обобщению это приятное исключение для LSP, а не правило
** Контрвариантность
- Мы говорим, что изменение типа контрвариантно к генерализации, если выполняется условие
  - если А обобщает В, то В' обощает А'
- Контрвариантны возвращаемые значение методов - если в производном классе есть метод, который возвращает IValue, его можно переписать чтобы он возвращал Value, потому что Value is-a IValue
** Обсуждение
- Именно ковариантность указателей и ссылок и их неподверженность срезке делают их отличными кадидатами в С++
- Но их использование приводит к неявным (incidental) структурам данных и убивает value-семантику

* (ISP) Разделение интерфейса
** Пример плохого проектирования
#+begin_src cpp
struct IWorker {
  virtual void work() = 0;
  virtual void eat() = 0;
  // ...
};
class Manager {
  IWorker *subdue;
  public:
  void manage() {
	subdue->work();
  }
};
class Robot : public IWorker {
  void work() override;
  void eat() override {
	// do nothing
  }
}
#+end_src
- do nothing -> нарушение принципа
- Следует писать небольшие интерфейсы с одной четко выраженной обязанностью

* (DIP) Инверсия зависимостей
- "Depndency is key problem in software development at all scales" (Kent Beck)
** Принцип инверсии зависимостей
- Высокоуровневые классы не зависят от низкоуровневых
- Вместо этого и те и другие зависят от абстракций
- Scheduler знает только об интерфейсе IDAG, следовательно то, что за этим интерфейсом легко заменить.
- Выражается в том что везде используется интерфейсы
- Интерфейсы зависят друг от друга
- Обьекты зависят только от интерфесов

* Немного о хорошем коде
** Гуманитарная состовляющая
- Де Марко и Листер писали, что программист в среднем занимается не научной или технической деятельностью, деятельностью социальной
- Это на сто процентов верно для бухгалтерии, веб-программирования и т.п.
- Но даже для компиляторостроения, высоконагруженных систем и всего такого интересного соотношение ~80/20 в пользу гуманитарных задач
- Программный код больше похож на чертеж здания, чем на доказательство теоремы. Поэтому говорят о "качестве", "архитектуре", "проекте"
- Поговорим о качестве. Что такое хороший код?
** Хороший код
*** Обьективные критерии качества есть, но они очевидно не о том
- Скорость работы
- Время до поставки пользователю
- Количество найденных дефектов на строчку
- Искусственные критерии вроде цикломатической сложности и т.д. (ну вобщем сомнительно, да)
*** Субьективные критерии ("когда я лично назову код хорошим")
- Читаемость
- Расширяемость
- Разумный выбор алгоритмов и абстракций
** Хороший код
- Многие принципы хорошего кода с первого взгляда спорны, но они формировались годами и написаны кровью
- Таковы принципы SOLID для ООП

* POLI и POLA
** Хороший код
- Таковы еще два важных принципа которые применимы вообще везде
- Law of Demeter или Principle of least information
  - Контекст не должен давать пользователю заглядывать в более низкие уровни абстракции напрямую
- Principle of least astonishment
  - То что программист видит в коде не должно его удивлять и запутывать
** Аллегория закона "Деметры"
- Всадник должен управлять лошадью, но не ногами лошади
- Было бы странно, если бы всадник получил интерфейс к нервам, позволяющим двигать ногами лошади напрямую
- Но именно это регулярно происходит в плохо спроектированных системах
** Пример плохого проектирования
- Здесь явно что то идет не так
#+begin_src cpp
class Options {
  Directory current_;
  // ...
  public:
  Directory &getDir() const; // return current_
  // ...
}
Options opts(args, argv);
string path = opts.getDir().getPath();
#+end_src
- А если кто нибудь захочет подставить другую реализацию директории? Нужно изобретать какой-то интерфейс
** Закон "Деметры"
- уберем раскрытие пользователю итерфейса напрямую
#+begin_src cpp
class Options {
  Directory current_;
  // ...
  public:
  string getPath() const; // returns current_.getPath()
  // ...
}
Options opts(argc, argv);
string path = opts.getPath();
#+end_src
** POLA, Пример плохого проектирования
- Допустим для удобства мы спроектировали множество перегрузки так
#+begin_src cpp
// parses "010" as 8, "0x10" as 16, "10" as 10
int strtoint(string s);
// respects user radix
int strtoint(string s, int radix);
#+end_src
- На какие проблемы может наткнуться невнимательно читавший документацию?
** POLA: убираем удивительное
- Для наименьшего удивления мы можем устроить функцию так
#+begin_src cpp
// radix = 10 if not specified
int strtoint(string s, int radix = 10);
#+end_src
- Теперь при неправильном использовании будет разумная ошибка
- Вторую можно оставить так
#+begin_src cpp
// parses "010" as 8, "0x10" as 16, "10" as 10
int smart_strtoint(string s);
#+end_src


** Литература и заключение

