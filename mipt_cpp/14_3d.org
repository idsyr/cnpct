#+title: Базовый курс C++ (MIPT, ILab). Lecture 14 (доп). OpenGL и Vulkan
#+author: idsyr

* Первый квадрат
** GPU как вычислительная система
- Видеокарта решает задачу рендеринга т.е. двумерного представления трехмерной сцены
- Эта задача сложна и специфична. Графические процессоры всегда отличались от CPU и с ними традиционно работают через разные API
- Если не требуется отрисовывать что либо сложное то встроенная графика которая идет через api операционной системы обычно достаточно быстрая (Host program)->(Window API(GLFW, SDL))->(Operating system API)->(Driver)->(GPU)
** Давайте отрендерим квадрат (как будто мы в 1994)
- OpenGL для рендеринга
#+begin_src C
glClear(GL_COLOR_BUFFER_BIT);
glBegin(GL_QUADS);
glColor3f(1.0, 1.0, 1.0);
for(auto Coord : Vertices) 
    glVertex3fv(Coord);
glEnd();
#+end_src
- GLFW для окон и управления
#+begin_src c
glfwSwapBuffers(Wnd.get());
glfwPollEvents();
#+end_src
* Фиксированный конвейер
- Фиксированные блоки
- Управление отдельными функциями
#+begin_src c
glEbable(GL_DEPTH_TEST);
glDeepthFunc(GL_LESS);
glEnable(GL_DEPTH_CLAMP);
glEnable(GL_CULL_FACE);
glClear(GL_COLOR_BUFFER_BUT);
#+end_src
- это тонна api фнкций и enums
* Понятие расширения
** Общение с рантаймом
- Каждый раз когда вы дергаете API функцию, вы дергаете рантайм, который должен в какой то момент послать инфрмацию драйверу
#+begin_src c
for(auto Coord : Vertices)
    glVertex3fv(Coord); // это вызов OpenGL runtime
#+end_src
- Проблема в том, что каждый такой API вызов предполагает накладные расходы, на которые вы идете каждый фрейм. И которые сложно кешировать.
- Нам наоборот хочется максимум отдать в память GPU и минимально с ней взаимодействовать
- Во многом это компенсируется тем, что в OpenGL возможны расширения
** Расширения OpenGL: буферы вершин
- Отрендерим тот же квадрат по другому: подготовим буферы вершин
#+begin_src c
glGenVertexArrays(1, &VAO);
glGenBuffers(1, &VBO);
glBindVertexArray(VAO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_SRAW);
#+end_src
- В цикле рендеринга теперь все стало куда приятней
#+begin_src c
glClear(GL_COLOR_BUFFER_BIT);
glBindVertexArray(VAO);
glDrawArrays(GL_QUADS, 0, 4);
#+end_src
** Расширения и версии
- Буфера вершин были введены расширением ARB_vertex_array_object в OpenGL 2.1 и закреплены в стандарте OpenGL 3.0
- Расширения предлагаются участниками косорциума и их реально десятки
- Существуют автоматизированные системы, такие как glad, запращивающие вам расширения и генерирующие хедер с доступными функциями
- Для более тонкого контроля есть библиотека GLEW, позволяющая проверять доступность расширений и многое другое
* Нефиксированный конвейер
- Первой идеей, появившейся достаточно рано была идея шейдера т.е. небольшой програмы для видеокарты, которая позволяла бы гибко управлять светом и тенью на каждой вершине
- Так в 2001 году в OpenGL 2.0 появился язык GLSL
- В программировании GPU есть своя специфика
** Вершинные шейдеры
- В примере с каждой вершиной связан цвет
#+begin_src c
// positions           // colors
0.5f,  0.5f,  0.0f,    0.0f, 1.0f, 0.0f,
#+end_src
- Этот цвет как атрибут вершины передается вы вершинный шейдер
#+begin_src glsl
layout (location = 0) in vec3 aPos;
layout (location = 1) is vec3 aColor;
out vec3 vColor;
...
vColor = aColor // выход во фрагменты
#+end_src
** Binding points: glBindBuffer
* Фрагментные шейдеры 
** Что такаое "Фрагмент"?
- Фрагмент это выход растеризатора
- Также можно сказать, что фрагмент это потенциальный пиксель
- Когда каждый элемент геометрии растеризуется, мы получем фрагменты на экране с двемерной позицией и цветом
- Фрагментный шейдер это программа, индивидуально работающая для каждого фрагмента и трансормирующия его.
** Вершинные шейдеры
- повтор
** Фрагментные шейдеры 33:07
- Вершинный шейдер сообщает цвет в out переменную
#+begin_src c
vColor = aColor; // выход во фрагменты
#+end_src
- Далее выходной цвет каждой вершины растеризуется и интерполируется
- Фрагментный шейдер добавляет синусоиду в синий канал каждого фрагмента:
#+begin_src c
gl_FragColor = vec4(xColor.xy, vColor.z + abs(sin(time)), 1.0);
#+end_src


** Uniform и verying переменные 34:38
- Шейдер работает сверхпараллельно и независимо: для каждого обьекта
- Переменная, варьирующаяся от обьекта называется varying. Общая на всех называется uniform (например время)
#+begin_src glsl
in vec3 vColor; // varying (приходит от растеризатора)
uniform float time; // uniform
void main() {
    for (f : all fragments) // не написано, но предполагается
        gl_FragColor = vec4(xColor.xy, vColor.z + abs(sin(time)), 1.0);
}
#+end_src


** Компиляция и исполнение шейдеров
- Необходимость компиляции делает графический драйфер гораздо сложнее: там появляется компилятор (вау!)
- Вызовы glCompileShader, glLinkProgram это вызовы возвращающие (возможно) ошибку и лог компиляции
- Компилятор OpenGL для графики Intel является LLWM-based и содержит более омптимизационных фаз
- При исполнении, шейдер можно включить через glUseProgram и можно переключить на другой


* Трехмерная графика
- У нас есть мировые координаты сцены. Внутри сцены расположена модель.
- Как перейти от координат сцены к координатам модели?
- Каким образом перейти от координат модели к координатам вида?
- Можно ли дополнительно учесть проекцию?
** Шейдер для трансформации (42)
** Давайте отрендерим куб
- Первый вариант: послать в режиме QUADS 6*4(по 3) вершин
- Второй вариант: 2 * 4 вершин(по 3), 6 * 4 индексов
#+begin_src c
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);
glBundBuffer(GL_ELEMENT_ARRAY_BUFFER, IBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(Indices), Indices, GL_STATIC_DRAW);
#+end_src
- Это несколько меньше данных для посылки на видеокарту (48 байт против 72) и это показывает еще одну binding point
* Culling и Depth
** Первая проблема: culling
- Небольшая ошибка с буферами индексов
#+begin_src c
GLubyte Indices[] = {
0, 3, 2, 1, 
0, 3, 7, 4,
};
#+end_src
- Демонстрирует face culling
** Вторая проблема: depth
- Даже если правильно угадать с буферами, но забыть depth и culling checks, все еще могут быть артефакты
#+begin_src c
glEnable(GL_DEPTH_TEST);
glDepthFunc(GL_LESS);
glEnable(GL_DEPTH_CLAMP);
glEnable(GL_CULL_FACE);
#+end_src
- Конвейер OpenGL плохо понимает что человек имел в виду. Для него выжен режим геометрии.
** Что  происходит в программе?
- Приложение формаирует геометрию шейдеры и прочее и кормит OpenGL API
- Кроме того приложение взаимодействует с оконным интерфейсом
- Который сам по себе может взаимодействовать с API, например для перерисовки 
- Где тут место для рендера?
** Обсуждение: что такое вершина?
- Атрибутами вершины могут быть
- Координаты 
- Цвет
- Нормали (для правильного освещения)
- Что угодно еще (у нас же программируемый конвейер)
- Значит рендерер должен как-то принимать обобщенный буфер вершин
** Идея сцены и простые вершины
- Класс 

