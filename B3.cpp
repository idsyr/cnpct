----------------------------------------------| Контесты |-----------------------------------------------
модуль, класс, функция это контекст
контекст инкапсулирует внутри себя данные - сохранение инварианта
сокрытие контекстом данных это механизм абстракции в линейной модели памяти
инвариант - утверждение выполняется на протяжении всей жизни обьекта

но оно не выполняется при malloc, полученный обьект находится в неконсистентном состоянии, поэтому:
int *p = new Widget[5]; delete[] p;

гарантия правильности вызова которых(new new[]) состоит в инкапсуляции:
вызовы должны быть нигде кроме как в конструкторе и деструкторе соответственно

----------------------------------------| Провисание ссылок |--------------------------------------------
scope and lifetime
декларация вводит в scope
декларация заканчивается до первого инициализатора
lifetime начинается после всех инициализаторов

-----//указатель, ссылащийся на переменную с истекшим временем жизни называется провисшим(dangling):
int a = 2;
void foo(){
    int b = a+3; int *pc;
    if(b>5){
        int c = (a+b)/2; pc = &c;}
    b+=*pc; //!
}



-----//dangling ref:
int *p = new int[5];
int &x = p[3];
delete[] p;
x+=1; //!

int& foo(){
    int x = 42;
    return x;
}
int x = foo(); //!



-----//продление жизни:
const int &lx = 0;
int x = lx; //ok
	    
int foo();
const int &ly = 42 + foo();
int y = ly; //ok



-----//временный обьект живет до конца полного выражения
struct S{
    int x;
    const int &y;
}
S x{1,2};//not a temp object
S *p = new S{1,2};//S is a temp object
в конце полного выражения lifetime S закончился



-----//c !const ref
int foo(int &x);
foo(1);//!
int &x = 1;//!

----------------------------------------------| Decaying and lvalues |-----------------------------------------
when rvalue ведет себя как что то простое
-----//ref == int 
int foo(const int& t){return t;} 


-----//array == array[0]
void foo(int *);
int arr[5];
int* t = arr + 3;//ok
foo(arr);//ok
arr = t;//!
----------------------------------------------| Cdecl и алиасы using |-----------------------------------------
void (*bar(int x, void (*func)(int&)))(int&);
typedef void (*ptr_to_fref)(int&);
ptr_to_fref bar(int x, ptr_to_fref func);

-----//но template alias нельзя создать через typedef, поэтому:
template <typename T>
using ptr_to_fref = void(*)(T&);

----------------------------------------------| Манглирование |-----------------------------------------
char *strstr(const char* str, cosnt char* substr);
чтобы передавать const и получть nonconst

C: гарантия по именам в asm
каст ссылки к значению которая арг функции, это каст указателя или значения?

extern "C"


-----------------------------------------| Правила перегрузки |-----------------------------------------
float sqrt(float x);
double sqrt(double x);
sqrt(42);// -> ошибка компиляции

1 точное совпадение ок
2 точных совпадения ошибка компиляции
если нет на уровень ниже

точное совпадение            int -> int, int -> const int&, etc
точное совпадение с шаблоном int -> T
стандартные преобразования   int -> char, float -> ushort, etc
переменное число аргументов  ...
неправильно связанные ссылки literal -> int&, etc

-----------------------------------------| Пространства имен |-----------------------------------------
//global
int x;
int foo(){return ::x;}


<stdlib.h> >>> <cstdlib> чтобы обернуть в std:: 
но не для макросов


namespace{
    int foo(){return 42;}
}
анонимный namespace - сделать namespace со сложным уникальным именем и сделать его using
как и static чтобы было видно только внутри модуля


не засорять глобальное пространство имен
никогда не писать using namespace в заголовочных файлах
использовать анонимное пространства имен вместо статических функций
не использовать анонимные прсотранства имен в заголовочных файлах


gdb: tui enable
x/20x T
x/20x T-2













