#+TITLE: Семинар 8.2. Решение уравнений и вычисление функций
#+AUTHOR: idsyr
#+STARTUP: showeverything
#+OPTIONS: toc:2




* Правила работы с плавающими числами (00:00)
- Избегайте сравнивать на равенство
- Будьте очень аккуратным с ошибками сложения
- Учитывайте конечный размер плавающих чисел
- Операции на числами не всегда возвращают числа
** Избегайте сравнивать на равенство
- Казалось бы сравнение должно выполнятся, но увы
#+begin_src cpp
d1 = 10.0;
d2 = sqrt(d1);
d3 = d2*d2;
if(d1==d3){
	// сюда мы можем и не попасть (зависит от округления)
}
#+end_src
- Правильный способ сравнивать: в пределах некоей погрешности
#+begin_src cpp
if(fabs(d1 - d3) >= 1e-5)
#+end_src




* Аккуратнее с ошибками сложения (10:20)
- В след примере мы пытаемся вычислить как можно более точную производную, измельчая шаг до предела double диапазона
#+begin_src cpp
double h, cosval;
for( i = 1; i<20; ++i){
	h = pow(10.0, -1);
	cosval = (sin(1.0 + h) - sin(1.0));
	printf("%d:\t%.15lf\n", i, cosval);
}
printf("True result: %.15lf\n", cos(1.0));
#+end_src




* Помните о конечности диапазона (16:04)
- Даже числа одинарной точности предоставляют гигантские дапазоны. Но конечные
- Это заметно при сложении с очень большими числами
#+begin_src cpp
f = 16777216.0f; // 2^24
nextf = f + 1.0f; // Побитово не отличается от f
#+end_src
- И при сложении с очень малыми
#+begin_src cpp
fone = 1.0f;
feps = 0.00000005f;
fenext = fone + feps; // побитово не отличается от fone
#+end_src
- С насколько маленькими можно складывать?
- FLT_EPSILON
** Ваш результат это не всегда число
- Следующий код позволяет получить бесконечность за конечное время
#+begin_src cpp
double d = 1.79e+308;
double infd = 2.0*d; // inf
double infdzero = infd * 0.0; // -nan
printf("d: %le\tinfd: %le\n", d, infd);
#+end_src




* Дихотомия (23:18)
- Допустим вы хотите найти корень уровнения
 - x^2*sin(x) - 5x + 7 = 0
- Вы знаете что он лежит где то в диапазоне от -3 до 3
- Для решения можно воспользоваться дихотомией: на каждом шаге делить отрезок пополам и если там значение совпадает по знаку с левым, то брать правый интервал и наоборот
- Это очень похоже на бинарный поиск в сортированном массиве
- Что вы будете сравнивать с выбранной вами точностью?
- Вариантов два: delta(x)(+) delta(y)




* Целочисленный квадратный корень (30:00)
#+begin_src cpp
unsigned isqrt(unsigned x){
	unsigned l = 0, r = x,  mid;
	while( l<r ){
		mid = (l+r+1)/2;
		if(x<mid*mid) r = mid-1;
		else          l = mid;
	}
	return l;
}		
#+end_src
#+begin_src cpp
unsigned isqrtd(unsigned x){
	double d = sqrt(x);
	fesetround(FE_DOWNWARD);
	return rint(d);   }
#+end_src




* Бенчмаркинг целочисленного корня (40:23)







* Regula falsi (45:11)
- Мы не используем информацию о динамике самой функции
- Метод ложной позиции 
- Пусть мы располагаем точками xk-1 and xk1, при этом xk>xk-1 и s[f(xk-1)]!=s[f(xk)]
- Посчитаем новую точку x
- (0) x = xk - f(xk)(xk-xk-1)/(f(xk)-f(xk-1)) 
- А далее в зависимости от знака s[f(x)] обновим
- либо xk+1 = xk, xk=x
- либо xk+1 = x, xk=xk-1



* Нарушим бректинг? И время для задач (49:08)
- Исследуя regula falsi, люди обнаружили интересную вещь. Из-за того, что в худшем случае один ее конец в итоге зафиксирован, сходимость у этого метода не лучше, чем у дихотомии
- Идея _метода секущих_ в том, что мы забиваем про брекетинг и всегда делаем: (0)
- То есть всегда обновляем обе границы в любом случае
- Да мы можем потеряться и разойтись, но зато скорость сходимости улучшается в разы
** Алгоритм SC - метод Риддерса
- Метод Риддерса основан на улучшенном fals position, но сходится быстрее
#+begin_src cpp
typedef double (*func)(double x);
double fsgn(double x) {return signbit(x)? -1.0 : 1.0; }
double secant(func_t f, double xleft, double xright){
	assert(fsgn(f(xleft)) != fsgn(f(xright)));
	// В цикле
	// xmid = (xleft + xright) / 2.0;
	// fl = f(xleft); fr=f(xright); fm=f(xmid);
	// xnew = xmid + (xmid-xleft) * fsgn(fl - fr) * fm/sqrt(fm*fm-fl*fr);
	// заменяем xleft=xnew или xright=xnew в зависимости от знака f(xnew)
	// Проверяем условие выхода из цикла fabs(f(xnew)) < presion
	return xnew;
#+end_src



* Метод Ньютона (54:50)
- Рассмотрим уравнение x^2+e^x-0.827185 = 0
- У него два действительных корня, но доввольно сложно выбрать два значения, в которых функция принимала бы разные знаки
- Что делать в этом случае?
** Внезапная идея
- Метод секущих - мы забыли про брекетинг
- Может быть запустить его с любой точки?
- Это так себе идея(если начать с любой точки то неясно как пойдут секущие), но можно сделать рабочей(хотелось бы иметь не секущую), заменив разность на производную(касательная ведет к корню)
#+begin_src cpp
struct func_deriv {double func; double der;};
typedef struct func_deriv (*fder_t)(double x);
double newton(fder_t f, double x){
	// xi+1 = xi-f(xi)/f'(xi)
}
#+end_src
- Проблемы со сходимостью - уход в inf и зацикл.
- Это происходит если изначальный гес был слишком далеко от корня


* Вычисление функций (01:00:32)
- Применение метода Ньютона
- Формула Герона





* Быстрые приближения и магический инверсный корень (01:14:30)
** Быстрый приближенный логарифм
| Число | Предстваление | - 0x3f00000 | Логарифм |
| 1.0f  |    0x3f800000 |  0x00000000 | 0.0f     |
| 2.0f  |    0x40000000 |  0x00800000 | 1.0f     |
| 4.0f  |    0x40800000 |  0x01000000 | 2.0f     |
- Из этого следует интересная формула
- log(x) ?= ([x as bits] - 0x3f800000) / 0x00800000
- После один щаг методом ньютона
** Быстрые приближения
- Быстрое возведение двойки в данную степень
- 2^x ?= [((unsigned) (x*(float)0x00800000) + 0x3f800000) as float]
- Квадратный корень
- ?= [(([x as bits] >> 1) + (0x3f800000 >> 1)) as float]
** Магический инверсный корень
- В качестве приближенного решения предыдущей проблемы будет работать следующая процедура
#+begin_src cpp
float magic_inv_sqrt(float y){
	double x2 = 0.5f*y;
	long i = to_long(y);
	i = 0x5f3759df - (i>>1);
	y = *(float *) &i;
	y = y*(1.5f -(x2*y*y));
	return y;
}
#+end_src




* Комплексные числа и фрактал Ньютона (01:20:15)
** Фракталы
- Несмотря на трудности которые создают проблемы со сходимостью, они же порождают фрактальную структуру
- Например рассмотрим в комплексных числах уравнение: x^3-1=0
- Для него есть такие z0 для которых метод Ньютона сходится и такие, для которых нет
- Из-за нестабильного поведения около локальных максимумов, область сходимости образует самоподобную кривую, то есть собственно фрактал
- Рисунки таких фракталов на комплексной плоскости могут быть крайне красивы
** Реализация фрактала Ньютона
- Функции в комплексных числах удобнее реализовать в комплексных числах
#+begin_src cpp
static complex double next(complex double z){
	complex double numerator = z*z*z-1;
	complex double denominator = 3*z*z;
	return z - numerator / denominator;
}
#+end_src
** Работа с комплексными числами
#+begin_src cpp
complex double a,b,c;
double re, im;
a = CMPLX(1.0, 2.0);
b = CMPLX(3.0, 4.0);
c = a*b;
re = creal(c);
im = cimag(c);
#+end_src




* Голоморфная динамика и множество Жюлиа (01:26:20)





* Генератор фракталов и завершение (01:31:58)





* Problem
- DH: дихотомия уравнений
- EC: исследование сходимости
- EN: решение методом Ньютона
- RI: иверсный корень
