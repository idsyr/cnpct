#+TITLE: Базовый курс C++ (MIPT, ILab). Lecture 3. Имена и сущности
#+AUTHOR: idsyr
#+DESCRIPTION: B1
#+STARTUP: showeveryhing
#+OPTIONS: toc:2




* Контексты (00:00)
- В языке С модуль это контекст
- В С++ класс это контекст
- функция тоже контекст
- Контекст инкапсулирует внутри себя данные
- однако отношения сокрытия нет, мы работаем в линейной модели памяти
- таким образом за пределами контекста сокрытие это невозможность использования как имя*




* New & Delete (04:00)
- malloc & free ничего не знают о конструкторах и деструкторах
- Созданный с их помощью в динамической памяти обьект не будет корректно инициализирован и будет создан в _невалидном состоянии_
- В языке С++ аллокация делается через new & delete 
#+begin_src cpp
int *t = new WIdget;
delete t;

int *p = new Widget[5]; // перед началом выделенной памяти хранит n
delete [] p;
#+end_src
- для эксплора памяти in gdb: x/20x <varname>




* Провисание ссылок (11:29)
** Область видимости
- У любого имени есть область видимости (scope): совокупность всех мест в программе, откуда к нему можно обратиться
- У любой переменной есть время жизни (lifetime): совокупность всех моментов времени в программе, когда ее состояние валидно



** Провисшие указатели
- Указатель, ссылающийся на переменную с истекшим временем жизни называется провисшим (dangling)
#+begin_src cpp
int a = 2;
void foo() {
  int b = a + 3;
  int *pc;
  if(b > 5) {
    int c = (a + b) / 2;
    pc = &c;
  }
  b +=pc; //this is parrot no more
}
#+end_src


#+begin_src cpp
int *p = new int[5];
int &x = p[3];
delete [] p;
x += 1; // it ceased to be
#+end_src


#+begin_src cpp
int& foo() {
  int x = 42;
  return x;
}
int x = foo(); // it expired and gone
#+end_src



** Продление жизни
- Константные (и только они) lvalue ссылки продлевают жизнь временных обьектов
#+begin_src cpp
const int &lx = 0;
int x = lx; // ok

int foo();
const int &ly = 42 + foo();
int y = ly; // ok
#+end_src
- Ссылка связывается со значением, так что тоже провисает



** Жизнь временных обьектов
- Временный обьект живет до конца полного выражения
#+begin_src cpp
struct S {
  int x;
  const int &y;
};
S x{1,2}; // ok, lifetime extended
S *p = new S{1,2}; // this is a alte parrot
#+end_src
- На первой строчке у нас не временный обьект, а постоянный обьект
- На второй будет висячая ссылка потому что временный обьект продлявший жизнь константе закончился в конце выражения
- Это особенность константных ссылок




* Decaying & lvalues (24:25)
- Ссылка на обьект в выражениях ведет себя как сам обьект
#+begin_src cpp
int foo(const int& t) {return t;}
#+end_src


- Массив деградирует (decays) к указателю на свой первый элемент, когда он использован как rvalue
#+begin_src cpp
void foo(int *);
int arr[5];
int *t = arr + 3;
foo(arr);
arr = t //fail
#+end_src



** Lvalue & rvalue
- В языке С концепция lvalue означала "left-hand-side value"
#+begin_src cpp
y = x;
#+end_src
- Здесь _y_ это lvalue, _x_ это rvalue
- В языке С можно отделить синтаксически: вызов функции, имя массива, выражение сложения - это все никогда не lvalue и технически не может встретиться в присваивании слева


- Так ли это в С++? (Нет, потому что есть ссылки и foo может возвращать ссылку)
#+begin_src cpp
int& foo();
foo() = x; // ok
#+end_src



** Lvalue & rvalue
- В языке С++ lvalue это скорее "location value" - в смысле что то у чего есть положение (location) в памяти
- В языке С++11 также есть более точный термин gvalue обьединяющий положения с временными положениями
- Ссылки рассматриваемые здесь это lvalue ссылки
- Технически может существовать lvalue ссылка на массив. Это происходит именно потому что, хотя массив и не может быть слева в присваивании, но он всегда lvalue в С++ потому что у него всегда есть локация (сам массив это локация по определению)




* Cdecl & алиасы using (30:55)
#+begin_src cpp
int *x[20]; // array of ptr
int (*y)[20]; // ptr to array
int (&z)[20] = *y; // ref to array
#+end_src


- Использование typedef
#+begin_src cpp
void (*bar(int x, void (*func)(int&))) (int&);

typedef void (*ptr_to_fref) (int&);
ptr_to_fref bar(int x, ptr_to_fref func);
#+end_src


- typedef ничего не знает о шаблонах, поэтому
#+begin_src cpp
using ptr_to_fref = void (*) (int&);
ptr_to_fref bar(int x, ptr_to_fref func);

template <typename T>
using ptr_to_fref = void (*) (T&);
#+end_src




* Манглирование (38:47)
** Одна забавная странность в языке С
- Функция strstr(haystack, needle) ищет подстроку needle в строке haystack
- Она определена странно
#+begin_src cpp
char *strstr(const char* str, const char* substr);
#+end_src
- const здесь не только гарантия неизменения
- const для того чтобы вызывать и с const char*
- и возвращается non const по той же причине



** Гарантии по именам
- Язык С предоставляет строгие гарантии по именам
#+begin_src cpp
double sqrt(double); // метка не будет зависеть от сигнатуры
#+end_src


- Язык С++ не дает гарантий по именам
#+begin_src cpp
double sqrt(double); // метка может зависеть от сигнатуры
#+end_src


- Кроме случая extern "C"
#+begin_src cpp
extern "C" double sqrt(double); // то же что и в С
#+end_src
- Последний случай введен чтобы согласовать API
- Процесс искажения имен называется манглированием
- Отсутствие манглирования означает стабильное API и стабильный ABI
- Перегрузить просто сущность с extern "C" сущностью нельзя




* Правила перегрузки (50:35)
** Разрешение перегрузки
- Наличие перегрузки вносит некоторые сложности
#+begin_src cpp
float sqrt(float x);
double sqrt(double x);
sqrt(42); // неясно что вызвать, оба варианта подходят
#+end_src
- В языке С++ есть перегрузка и компилятор должен разрешить имя, то есть связать упомянутое в коде имя с обозначаемой им сущностью

  

** Правила разрешения перегрузки
- Первое приближение
  1. Точное совпадение (int -> int, int -> const int&)
  2. Точное совпадение с шаблоном (int -> T)
  3. Стандартные преобразования (int -> char, float -> unsigned short)
  4. Переменное число аргмументов
  5. Неправильно связанные ссылки (literal -> int&)
- 4: for SFINAE

  

** Перегрузка конструкторов
- Методы класса, разумеется, тоже можно перегружать и наиболее полезно это для конструкторов
#+begin_src cpp
class line_t {
  float a_ = -1.0f, b_ = 1.0f, c_ = 0.0f;
public:
  line_t(){}
  line_t(const point_t &p1, const point_t &p2);
  line_t(float a, float b, float c); 
}
#+end_src




* Пространства имен (1:04:35)
- Любое имя принадлежит к какому то пространству имен
#+begin_src cpp
// no namespace here
int x;
int foo(){
  return ::x;
}
#+end_src
- x принадлежит к глобальному пространству имен



** Пространство имен std
- Вся стандартная библиотека принадлежит к пространству имен std
#+begin_src cpp
std::vector, std::string, std::sort
#+end_src
- Исключение это старые хедера наследованные от С, такие, как <stdlib.h>
- Чтобы завернуть atoi в std, сделаны новые хедера, такие, как <cstdlib>
- Вы не имеете права добавлять в стандартное пространство имен свои имена
- Точно по той же причине по какой вы не можете начинать свои имена с подчеркивания и большой буквы



** Ваши пространства имен
- Пространства имен можно неограниченно вкладывать друг в друга 
- При этом струткуры тоже вводят пространства имен
- Можно использовать, но пространства имен как раз нужны чтобы отметить что это не тип



** Директиыв using, второй смысл
- Мы можем вводить отдельные имена и даже целые пространства имен
#+begin_src cpp
namespace X{
  int foo();
}
using std::vector;
using namespace std // yaaa
vector<int> v; v.push_back(foo());
#+end_src



** Анонимные пространства имен
- Это распространенный механизм для замены статических функций
- Сделать сложный уникальный namespace и сделать его using



** Правила хорошего тона
- Не засорять глобальное пространство имен
- Никогда не писать usong namespace в заголовочных файлах
- Использовать анонимные пространства имен вместо статических функций
- Не использовать анонимные пространства имен в заголовочных файлах




* Завершение: опять hello world
- единственная фукнция которой нужно засорить глобальное пространство имен это main
#+begin_src cpp
#include <iostream>
namespace {
  const char * const helloworld = "Hello, World!";
}
int main(){
  std::cout << helloworld << std::endl;
}
#+end_src
