#+TITLE: Базовый курс C++ (MIPT, ILab). Lecture 2. Указатели и ссылки
#+AUTHOR: idsyr
#+DESCRIPTION: B2
#+STARTUP: showeveryhing
#+OPTIONS: toc:2



* Genesis (00:00)
- Дано 4 бита и им сопоставляются 3 основные штуки!
- Семантическое значение
- Value диапазон
- Имя


** Типы: value types & object types
- Что такое тип?
 - value type: диапазон значений обьекта
 - object type: совокупность операций над обьектом
  - Например 5/2 даст 2 для типа int но 2.5 для типа double
  - 0-1 даст -1 для char, но 255 для unsigned char
- статическая типизация - тип навсегда связан с именем (а не с конкретной ячейкой) 
- Между обьектами существуют пространственные отношения
- существует RAM модель памяти
- расстояние от начала памяти до начала обьекта - адрес
- тип адреса - это указатель
- CHAR_BIT - сколько бит в char
 - char - минимально адресуемая ячейка


** Нулевые указатели
- Если указатель это просто расстояние, может быть и нулевое
- Нулевой указатель это специальный "маркер ничего". По нему ничего не лежит
- Не надо путать 0, NULL, nullptr
#+begin_src cpp
if(!p){smth();} // сработает во всех 3х случаях
#+end_src
- В языке С++ наш выбор это nullptr из за перегрузки функций


** Индексация указателей
- Изначально указатели всегда были указателями внутрь массивов, поэтому поддерживается синтаксис
#+begin_src cpp
p[2] == *(p + 2)
#+end_src
- Поскольку сложение коммутативно, 2[p] тоже сработает




* Ссылки (15:38)
** lvalue references
- И если бы речь о языке С, то это было бы все. Но в С++ есть уникальная возможность: два имени у одного обьекта 
- Единожды связанную ссылку нельзя перевезать
- С и С++ оперирует абстрактной execution model. Любой полученный валидным путем(корректно вернула корректно вызванная функция) указатель находится в абстрактной модели исполнения и в таком качестве является валидным указателем
- константная ссылка создает временный обьект
#+begin_src cpp
int foo() {return 42;}
int main(){
  int x;
  int &rx = x;
  const int &l = foo();
  std::cout << &l << " " << &x << &rx << std::endl;
}
#+end_src
-  мы увидим два обьекта на стеке
 - один который создала эта ссылка
 - второй x


** Использование ссылок
- Представим функцию, которой нужно читать два тяжелых обьекта
- Эта сигнатура плоха
#+begin_src cpp
int foo(Heavy fst, Heavier snd);
#+end_src


- Эта сигнатура куда лучше, но придется разыменовать указатели
#+begin_src cpp
int foo(const Heavy *fst, const Heavier *snd);
#+end_src


- Эта сигнатура использует указатели неявно
#+begin_src cpp
int foo(const Heavy &fst, const Heavier &snd);
#+end_src


- Внутри одного стекового фрейма ссылка это другое имя обьекта
- Но при передаче в другой стековый фрейм это ссылка
- Ссылка не может быть nullptr, не может быть невалидна, невозможна адресная арифметика
- Out аргументы плохи



 
* Треугольники (36:11)
- end-to-end и модульное(unit) тестирование 




* Инкапсуляция (50:54)
- Ничто не мешает пользователю создать полигон не удовлетворяющий условию отсортированности по кругу
- На языке С мы хотим загнать структуру в отдельный модуль и сделать так чтобы все функции которые оперируют над структурой знали что некоторый инвариант сохраняется (по построению)
- Однако мы заплатили за это невозможностью создания на стеке и теперь мы не можем эффективно инлайнить функции
- Инкапсуляция(скрытие состояния обьекта) позволяет сохранять инвариант класса


 

* Нарушение инкапсуляции (58:48)
- У нас есть линейная модель памяти
- По крайней мере для standart--layout и для trivially copyable мы можем привести обьект к char* и нарушить все инварианты, но мы не хотим этого делать
- ссылка это разновидность инкапсуляции указателя
#+begin_src cpp
int foo(const int *p) {int t  = *p; delete p; return t;}
int bar(const int &p) {return p;}
foo(nullptr); // это невозможно проделать с bar
double d = 1.0;
int *q = *reinterpret_cast<int **>(&d);
foo(q); // это невозможно проделать с bar
#+end_src


 - Инвариант const int reference: правильное и не вам принадлежащее целое число под ней. Именно поэтому побитовое представление ссылки скрыто


** Важное замечание
- Инкапсуляция это свойство типа а не его обьектов
 - concat_with возможен с обьектом параметризованным тем же типом
 - Но невозможен с обьектом с другим Т
- модификатор private про использование имен внутри методов типа
- модификаторы делают критически важными конструкторы и деструкторы




* Задание, обзор литературы, вопросы (01:08:28)










