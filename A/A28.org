#+TITLE: Интермедия. Стандарт языка C.
#+AUTHOR: idsyr
#+STARTUP: showeverything
#+OPTIONS: toc:2




* Язык программирования INC и поведение программ (00:00)
- Что такое язык программирование вообще?
- Как по некоему исходному тексту определить является ли он вообще программой на C
** Небольшой опыт стандартизации
- Язык INC содержит четыре переменных: a,b,c,d, символы +, post++, =, ; а также константа 0. Каждую можно инкрементировать и складывать с другими. В каждую можно описать результат
- Каждая запись в переменную d это вывод на экран
#+begin_src cpp
a = 0; b = a++; c = a+b++ + a; d = c;
#+end_src
- примеры:
#+begin_src cpp
x = 0;    // лексическая ошибка
a = b++c; // грамматическая ошибка
0 = a;    // семантическая ошибка
a = a++;  // неопределенное поведение
a = 0; c = b = a++; c = a; d = c; // ненужное присвоение
a = 0; b = a++ + a++ + a++; d = a + b; // неупорядоченные модификации
#+end_src



 
* Семантика и стандарт языка (12:38)
** Задача которую решает компилятор
- Есть операционная семантика языка
#+begin_src cpp
a = b++ // запиши в а значение b, увеличь на один
#+end_src
- Есть возможности реальной аппаратуры
#+begin_src asm
  mov r1, r0
  inc r0  
#+end_src
- Они не всегда точно совпадают
- Компилятор должен пересказать программу в терминах вычслительного устройства, сохранив ожидаемое поведение (as-if rule) и выполнив оптимизации
- так например на -O2:
#+begin_src cpp
int fact(int x){return (x<2)? x : x*fact(x-1);}
int main(){printf("%d\n", fact(5));
#+end_src
- станет:
#+begin_src asm
mov esi, 120
#+end_src
- но fact(int): останется, ведь у нее external linkage, однако он перестанет быть рекурсивным:
#+begin_src asm
fact(int):
  cmp edi, 1
  jle .L4
  mov eax, 1
.L3:
  mov edx, edi
  sub edi, 1
  imul eax, edx
  cmp edi, 1
  jne .L3
.L4:
  mov eax, edi
  ret
#+end_src
- Чтобы решать такую сложную задачу компилятор должен знать все о языке, и язык который он компилирует определяется стандартом языка
** Стандарт языка
- Язык программирования это соглашение между программистом и разработчиком компилятора
- Как таковое, оно задокументировано в стандарте языка
- Именно стандарт, а не конкретная реализация является последним и рещающим аргументом в вопросе о том, что является программой, что нет и какая программа работает верно, а какая нет
- Действующий стандарт С это ISO/IEC 9899-2018 принятый в 2018
** История языка это история стандартов
- С 1972 по 1989 год - до-сдандартный период. Стандартом де-факто было книга [K&R], поэтому иногда говорят о "K&R C language"
- Принятие ISO/IEC 9899-1990, также обозначаемого С90 поддержка которого сейчас реализована во всех компиляторах всех платформ (там где переменные сверху)
- Принятие -1999 - С99 поддержка которого широко распространена, но не везде он поддержан полностью 
- Принятие -2011, С11 он полностью поддержан в gcc и без опциональных частей в clang/llvm (появились потоки)
- -2018, по сути техничские правки в C11
* Некоторые особенности С90
#+begin_src c
#include <stdio.h>    /* C90, // не было           */
static x;             /* static int x;             */
main(void){           /* int main(void){           */
  auto i;             /* auto int i;               */
  for(i=0; i<5; i+=2) /* can not: for(int i = 0... */
    x+=i;
  printf("%d\n", x);
  return 0;           /* mnadatory in C90          */
}
#+end_src
- Всюду можно было пропускать тип -> по умолчанию int
- Переменная на стеке -> автоматическая
** Обсуждение
- По умолчанию в компиляторе gcc
 - До gcc 5.1 был C90
 - Начиная с gcc 5.1 установлен С11
 - Начиная с gcc 8 установлен С18
- Дополнительная опция -pedantic позволяет чуть более педантично контролировать соответствие стандарту
- Соответствующий стандарту код назвается conforming и имеет однозначную семантику исполнения в абстрактной машине языка
* Синтаксис и семантика
- Стандарт языка это список синтаксических и семантических правил
- Синтаксические правила можно проверить в грамматике языка
#+begin_src cpp
int a = +; // syntax violation
#+end_src
- Семантические иногда можно проверить
#+begin_src cpp
int foo(int) // определена
int bar(int x){return foo(x)}; // вызвана с правильным числом аргументов
#+end_src
- Реализация в идеале должна транслировать программу либо выдать диагностику




* Поведение программ (23:50)
- Синтаксически некорректные
- Синтаксически корректные
 - strictly conforming behavior [C11 4.5]
 - implementation-defined behavior
 - unspecified behavior
 - undefined behavior
- Implementation limits (пределы гарантированной поддержки)
- Hosted и Freestanding environment (может ли компилятр догадываться о функциях стандартной библиотеки)
** Implimentation limits
- 127 neting levels of blocks (стандарт разрешает компилятору не компилировать если больше)
- 63 nesting levels of conditional inclusion
- 12 pointer, array, and function declarations (in any combinations) modifying an arithmetic, structur, union, or void type in a declaration
- 63 nesting levels of parenthesized declarators within a full declarator
- 63 nesting levels of parenthesized expressions within a full expression
- 63 significant initial characters in an internal identifier or a macro name
- 31 significant initial characters in an external indentifier (gcc хеширует имена)
- ... 
- И это пределы strictly conforming
** Implementation defined
- Простейший пример это размер типа int
#+begin_src cpp
int main(void){
  printf("%d\n", sizeof(int));
#+end_src
** Unspecified
- Порядок вызова функций без установленных отнощений последования
#+begin_src cpp
#include <stdio.h>
int foo() {printf("%s\n", "foo"); return 0;}
int bar() {printf("%s\n", "bar"); return 1;}
void buz(int x, int y) {printf("%s %d %d\n", "buz", x, y);}
int main() {buz(foo(), bar());}
#+end_src




* Неопределенное поведение (34:15)
** Undefined
- NULL pointer dereference
#+begin_src cpp
int deref(int* a){
  return *a} // UB if NULL ptr dereference
#+end_src
- Более забавный случай - целочисленное переполнение
#+begin_src cpp
int mult(int a, int b){
  return a*b;}
#+end_src
- Звучит странно, но если здесь результат не влезает в целочисленный тип, компилятор имеет право сделать его каким угодно
- В unsigned арифметика по модулю
** Свобода бездействия
- На всех известных KV компиляторах выведет 42:
#+begin_src cpp
#include <stdio.h>
int foo(int c){
  int x,y;
  y = c?x:42;
  return y;
}
int main(){
  printf("%d\n", foo(1))};
#+end_src
** Tricky case
- Чуть более сложный пример
#+begin_src c
int k, satd = 0, dd, d[16];
// ...
for(dd = d[k = 0]; k < 16; dd = d[++k])
  satd += (dd < 0 ? -dd : dd);
#+end_src
- На шаге k==15 он станет 16
- d[16] это выход за границы массива, такого быть не может
- если такого не может быть, то k никогда не станет равно 16
- если k не станет равно 16 цикл не закончится
- цикл становится бесконечным
** Точка зрения компилятора
- неопределенное поведение это простор для оптимизаций
#+begin_src c
int elt = arr[idx]; // Выход за границы массивы это UB значит мы его не учитываем
y = c ? x : 42; // Возможность, что с == true это UB, значит мы ее не рассматриваем 
#+end_src
- Удивительно, но компилятор сознательно слеп в отношении UB
- Мы следуем так называемому "Узкому контракту"
** Исправляем ситуацию
#+begin_src cpp
int mult(int a, int b){
  return a*b;}
#+end_src
- b!=0 && a < (INT_MAX/b)
** Чего опасаться
- Целочисленное знаковое переполнение
- Деление на ноль
- Некоторые случаи сдвигов
- Приведение целого числа к слишком узкому типу
- Попытка изменить константный обьект приведением
- Модификация не упорядоченная по побочным эффектам (самое мрачное)
- Разыменование нулевого указателя
- Обращение за границами массива (_это точка невозврата_)
- Обращение к неиницилизоаванной переменной
- Использование указателя на истекший или удаленный обьект
- Доступ к значению через несовместимый тип
- Использование некоторых библиотечных функций (например memcpy с пересекающимися участками памяти)



* Тренировка в чтении стандарта и время решать задачи (47:17)
* Немного информации про проект и live coding (50:20)



* Стандарт как источник знаний (01:08:43)
** Упорядочение побочных эффектов
- Ключевым в абрстрактной машине языка С является понятие побочного эффекта (С11, 5.1.2.3) и отношения следования над побочными эффектами
- Примеры побочных эффектов: вывод на экран, печать в файл, сохранение в глобальную переменную
- Побочные эффекты должны быть упорядочены (отношениями последования)
#+begin_src cpp
x = 5; x = x + 1; foo(++x);
#+end_src
- Стандарт (С11, 6.5.2) гласит, что если побочный эффект на скалярный обьект не упорядочен с другим побочным эффектом или со значеним скалярного обьекта, то это UB
#+begin_src cpp
x = x++ + ++x; // undefined
#+end_src
** Стандарт как источник знаний
- Допустим вы читаете код и видите там следующую ( к счастью крайне редкую ) конструкцию
#+begin_src cpp
void f(double a[restrict static 3][5]);
#+end_src
- Используйте стандарт (С11, 6.7.6.3) чтобы понять что означает это обьявление
- Никогда не пишите такие конструкции (например потому что они чудовищно не совместимы ни с ранними версиями С ни с С++)
#+begin_src cpp
enum {MAX = 100;}
int arr[MAX] = {1, 3, 5, [MAX-3] = 8, 4, 3};
#+end_src
** Странности inline
- Используя компилятор gcc побробуйте откомпилировать код
#+begin_src c
inline void my_assert(int b, const char *str){
  if(!b) return;
  fprintf(stderr, "Assertion failed: %s\n", str);
  exit(-1);
}
int main(int argc, char **argv){
  my_assert(argc > 0, "argc <= 0");
  return 0;
}
#+end_src
- С опциями 
 - --std=c90  
 - --std=gnu90
 - --std=c99(по умолчанию) - my_assert(.) not found потому что это extern inline функция
- extern inline функция либо инлайнится либо игнорируется и ищется внешняя
- семантика: заглушка, котрую можно заинлайнить если это выгодно, либо поискать настоящую функцию если заглушку заинлайнить не получилось
- В С++ смысл extern inline принципиально другой
- Поэтому нужно писать static inline






* Важность стандартизации (01:19:11)
- Конкретные формулировки в стандарте очень важны
- Пример: знаменитая memmove/memcpy saga когда внезапно оказалось, что ядро Линукс много лет закладывалось на некорректное понимаение memcpy
- Стандарт это контракт
- Контракты пишуться людьми и для людей, но содержание их пунктов и даже мелкий шрифт имеют значение
- _Не менее важно чем любые другие нормативные документы_






