#+TITLE: Семинар 8.1. Матрицы и линейное программирование 
#+AUTHOR: idsyr
#+STARTUP: showeverything
#+OPTIONS: toc:2




* Правила работы с плавающими числами (00:00)
- Избегайте сравнивать на равенство
- Будьте очень аккуратным с ошибками сложения
- Учитывайте конечный размер плавающих чисел
- Операции на числами не всегда возвращают числа
** Избегайте сравнивать на равенство
- Казалось бы сравнение должно выполнятся, но увы
#+begin_src cpp
d1 = 10.0;
d2 = sqrt(d1);
d3 = d2*d2;
if(d1==d3){
	// сюда мы можем и не попасть (зависит от округления)
}
#+end_src
- Правильный способ сравнивать: в пределах некоей погрешности
#+begin_src cpp
if(fabs(d1 - d3) >= 1e-5)
#+end_src




* Аккуратнее с ошибками сложения (10:20)
- В след примере мы пытаемся вычислить как можно более точную производную, измельчая шаг до предела double диапазона
#+begin_src cpp
double h, cosval;
for( i = 1; i<20; ++i){
	h = pow(10.0, -1);
	cosval = (sin(1.0 + h) - sin(1.0));
	printf("%d:\t%.15lf\n", i, cosval);
}
printf("True result: %.15lf\n", cos(1.0));
#+end_src




* Помните о конечности диапазона (16:04)
- Даже числа одинарной точности предоставляют гигантские дапазоны. Но конечные
- Это заметно при сложении с очень большими числами
#+begin_src cpp
f = 16777216.0f; // 2^24
nextf = f + 1.0f; // Побитово не отличается от f
#+end_src
- И при сложении с очень малыми
#+begin_src cpp
fone = 1.0f;
feps = 0.00000005f;
fenext = fone + feps; // побитово не отличается от fone
#+end_src
- С насколько маленькими можно складывать?
- FLT_EPSILON
** Ваш результат это не всегда число
- Следующий код позволяет получить бесконечность за конечное время
#+begin_src cpp
double d = 1.79e+308;
double infd = 2.0*d; // inf
double infdzero = infd * 0.0; // -nan
printf("d: %le\tinfd: %le\n", d, infd);
#+end_src




* Дихотомия (23:18)
- Допустим вы хотите найти корень уровнения
 - x^2*sin(x) - 5x + 7 = 0
- Вы знаете что он лежит где то в диапазоне от -3 до 3
- Для решения можно воспользоваться дихотомией: на каждом шаге делить отрезок пополам и если там значение совпадает по знаку с левым, то брать правый интервал и наоборот
- Это очень похоже на бинарный поиск в сортированном массиве
- Что вы будете сравнивать с выбранной вами точностью?
- Вариантов два: delta(x)(+) delta(y)




* Целочисленный квадратный корень (30:00)






* Бенчмаркинг целочисленного корня (40:23)







* Regula falsi (45:11)







* Нарушим бректинг? И время для задач (49:08)






* Метод Ньютона (54:50)






* Вычисление функций (01:00:32)






* Быстрые приближения и магический инверсный корень (01:14:30)






* Комплексные числа и фрактал Ньютона (01:20:15)






* Голоморфная динамика и множество Жюлиа (01:26:20)





* Генератор фракталов и завершение (01:31:58)





* Problem
- DH: дихотомия уравнений
