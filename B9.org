#+TITLE:Базовый курс C++ (MIPT, ILab). Lecture 9. Множественное наследование
#+AUTHOR: idsyr
#+DESCRIPTION: B1
#+STARTUP: showeveryhing
#+OPTIONS: toc:2



* Изобретаем множественное наследование
** Множественное наследование 
#+begin_src cpp
  class MyArray : protected MyBuffer, public Array {
    public:
      explicit MyArray(int size) : MyBuffer(size), Array(???) {}
      // ,,,
  };
#+end_src
- Синтаксис наследования: все базовые классы с модификаторами через запятую
- Здесь наследование защищенное потому что:
  - мы не хотим прятать защищенную часть MyBuffer и не можем сделать его приватным
  - мы не хотим показывать MyBuffer наружу и не можем сделать его публичным
- Что написать вместо знаков вопроса?



** Решение: прокси-класс
#+begin_src cpp
  struct ProxyBuf {
    MyBuffer buf;
    explicit ProxyBuf(int size): buf(size) {}
  };
  class MyArray: protected ProxyBuf, public Array {
    public:
    explicit MyArray(int size) : ProxyBuf(size), Array(&ProxyBuf::buf) {}
    // ,,,
  };
#+end_src
- Теперь все срастается


** Обсуждение: сама идея сомнительна
- Множественное наследование интерфейса не вызвает вопросов
- Но в довольно большом количестве языков _запрещено множественное наследование реализации_. И сделано это неспроста.
- Первый смысл публичного наследования is-a (генерализация), второй смысл это расширение
- Первый смысл приватного наследования это part-of, второй смысл это расширение
- Абстрактный класс (класс интерфейс) - это способ оторвать первый смысл наследования от второго 






* Ромбовидные схемы и виртуальное наследование
** Ромбовидные схемы
#+begin_src cpp
  struct File { int a; };
  struct InputFile : public File { int b; };
  struct OutputFile : public File { int c; };
  struct IOFile : public InputFile, public OutputFile { int d; };
#+end_src
** Проблемы ромбовидных схем
- Поскольку в обьект класса входят два верхних подобьекта, доступ к переменным неочевиден
#+begin_src cpp
  IOFile f{11};
  int x = f.a; // error
  int y = f.InputFile::a; // ok, но это боль
#+end_src
- Кроме того в принципе f.InputFile::a и f.OutputFile::a могут и разойтись в процессе работы
- В качестве решения хотелось бы иметь один экземпляр базового класса сколькими путями он не пришел в производный
- Такие базовые классы называются виртуальными


** Виртуальные базовые классы
- Виртуальное наследование это поддержка в языке
#+begin_src cpp
  struct File { /*....*/ };
  struct InputFile : virtual public File { /*...*/ };
  struct OutputFile : virtual public File { /*...*/ };
  struct IOFile : public InputFile, public OutputFile { /*...*/ };

  IOFile f{11{;
  int x = f.a; // ok
  int y = f.InputFile::a; // ok, тоже работает
#+end_src
- И будет учитываться конструктор самого общего базового класса (_остальные будут проигнорированы_)
- И мы _обязаны_ вызвать конструктор самого общего базового класса в самом нижнем классе

** Вопросы
- Что если базовый класс виртуальный не по всем путям? ----> Никаких проблем, вниз попадет один со всех виртуальных путей и по одному с каждого невиртуального
- Что если базовый класс виртуальный но в нижнем подобьекте всего один? ----> Никаких проблем, можно хоть все базовые классы всегда делать виртульными, будет работать как обычное наследование (только хуже - дополнительные уровнии косвенности)
- В каком порядке и когда конструируются обычные и виртуальные подобьекты? Такое чувство что сначала должны конструироваться все виртуальные а потом все остальные 


** Виртуальные базовые классы 2
- Вызов виртуальной функции при множественном наследовании должен пройти через дополнительный уровень диспетчерезации
- А при виртуальном наследовании через еще один дополнительный уровень из-за того, что таблицы для виртуальных подобьектов должны быть отдельно смержены


** Списки инициализации
- Виртуальный базовый класс обязан появиться в инициализации самого нижнего подобьекта
#+begin_src cpp
  struct InputFile : virtual public File { 
    InputFile() : File(smths1) {} // Этот File() не вызовется для IOFile
  };
  struct OutputFile : virtual public File {
    OutputFile() : File(smths2) {} // Этот File() не вызовется для IOFile
  };
  struct IOFile : public InputFile, public OutputFile {
    IOFile() : File(smths3), InputFile(), OutputFile() {}
  };
  
  IOFile f; // Вызовет File(smths3)
#+end_src


** Case study: сложная диаграмма
- Вначале виртуальные (Вначале их предки)
- Потом ну как то там не знаю слева направо
- Потом поля цели
- Потом нижний


** Обсужление
- Множественное наследование уже кажется *МРАЧНЫМ?*
- Это мы еще не дошли до по-настоящему мрачных вещей
- Дело в том, что проблемы возможны не только с ромбовидными схемами




* Проблема каста вниз
** Проблемы преобразований 
- Для того, чтобы при одиночном наследовании преобразовывать вверх или вниз по указателю или ссылке достаточно static_cast
#+begin_src cpp
  struct Base{};
  struct Derived : public Base {};
  Derived *pd = new Derived{};
  Base *pb = static_cast<Base*>(pd); // ok
  pd = static_cast<Derived*>(pb); // ok
#+end_src
- Сработает ли такой подход при множественном наследовании?
- Как ни странгно все магическим образом прекрасно работает при касте вверх
#+begin_src cpp
  struct B1 {};
  struct B2 {};
  struct D : B1, B2 {};

  D *pd = new D{};
  B1 *pb1 = static_cast<B1*>(pd); // ok
  B2 *pb2 = static_cast<B2*>(pd); // ok
#+end_src
- Мало того, все магическим образом работает и вниз


** Обсуждение
- Такое чувство что при виртуальном наследовании из-за смерженных таблиц не должен работать каст вниз?



* RTTI и dynamic_cast
** Runtime Type Information
- Для разрешения насущных вопросов (например "какой у меня динамичеаский тип") и свободного хождения вниз-вверх по иеархиям классов, программа на С++ должна во вемя исполнения поддерживать особые невидимые программисту структуры данных 
- Это очень странное решение для С++ потому что оно противоречит идеологии языка
- В языке равно два таких сомнительных механизма: RTTI и исключения
- Много раз делались попытки завести к ним какой нибудь третий, но других ошибок с 1998 года комитет ни разу не делал
- И конечно основа RTTI это typeinfo


** Возможности typeid
- Оператор typeid возвращает обьект std::typeinfo который можно сравнивать и можно выводить на экран
- Этот обьект представляет собой динамический или статический тип
#+begin_src cpp
  OutputFile *pof = new IOFile{5};
  assert(typeid(*pof) == typeid(IOFile)); // динамический тип
#+end_src
- typeid может брать type или expression, если он берет expression то динамический то выводится только если это lvalue expression обьект с хотя бы одной виртуальной функций
#+begin_src cpp
  assert(typeid(pof) != typeid(IOFile*)); // статический тип
#+end_src


** Возможности dynamic_cast
- Самым распространенным (и самым накладным) механизмом RTTI является dynamic_cast. Он может приводить типы внутри иерархий
#+begin_src cpp
  IOFile *piof = new IOFile{}; // File это виртуальная база
  File *pf = static_cast<File *>(piof); // ok
  InputFile *pif = dynamic_cast<InputFile *>(pf); // ok
  OutputFile *pof = dynamic_cast<OutputFile *>(pf); // ok
  pif = dynamic_cast<InputFile *>(pof); // OK!
#+end_src
- Возможно приведение к сестринскому типу





* Обсуждение ошибок в RTTI и литература
** Поведение dynamic_cast при ошибке
- В случае, если dynamic_cast не сможет привести указатель, он возвращает нулевой указатель
#+begin_src cpp
  OutputFile *pof = new OutputFile{13};
  InpitFile  *pif = dynamic_cast<InputFile *>(pof);
  assert(pif == nulltpr);
#+end_src
- Но что он может сделать если он используется для ссылок? Ведь нет никакой "нулевой ссылки".
#+begin_src cpp
  OutputFile &rof = *pof;
  InputFile  &rif = dynamic_cast<InputFile &>(rof);
#+end_src
- (Он бросит exception)


** Обсуждение
- На самом деле у нас накопилось уже несколько вопросов
- Что делать dynamic_cast если он работает для ссылок?
- Что возвращать typeid если он работает для ссылок?
- Как вернуть код ошибки из перегруженного оператора сложения?
- Похоже в языке должен быть некий фундаментальный механизм, отвечающий за такие вещи. И этот механизм - исключения 
- Почему мы не хотим делать abort? -> Деструкторы




* Автоматы и регулярные выражения
** Алфавиты и строки
- Алфавит это множество символов, например {a,b,c}
- Строкой называется последовательность символов, например w = {a,a,c,b}
- Для краткости можно записывать w = aacb. Пустая строка <lamda>
- Конкатенация строк: w = aacb, z = ba, wz = aacbba, zw = baaacb
- Степень: w^3 = www, w^0 = <lamda>


** Формальные языки
- Ограничемся простым алфавитом {a,b,c}
- Язык L1 = {a^m b^n}: a, ab, aab, aabb, abb aaabbb, ...
- Язык L2 = {a, cab, caabc}
- Язык L3 = {a^n b^n}: ab, aabb, aaabbb, ...
- Язык L4 = {a^m b^n c a^m b^n}: aca, abcab, aabcaab, ...
- Язык L5 = a, b, ba, bab, babbabab, ... (строки Фибоначчи, начиная с a,b)
- Такие описания несколько неформальны и их сложно расширять
- Но сейчас можно понять, что нам предстоит решать задачи на языках 


** Задачи для формальных языков
- Принадлежность: имея язык L и строчку w, определить принадлежит ли она языку
- Порождение: имея язык L, порождать все его строки последовательно
- Эквивалентность: имея язык L1 и язык L2, определить принадлежат ли им одинаковые элементы
- Отрицание: имея язык L1, описать язык L2, такой, что он содержит все строки, не принадлежащие L1
- Чтобы решать все эти задачи, мы хотели бы простого и формального описания языка. И первой попыткой традиционно будут регулярные выражения. 


** Регулярные выражения
- Любой алфавитный символ означает язык из этого символа: a это {a}
- Конкатенация LxLy
- Дизьюнкция (Lx + Ly)
- Замыкание (Lx)*
- Язык L1 теперь можно описать как a*b*


** Расширенные регулярные выражения
- Довольно часто регулярные выражения расширяются еще двумя символами
  - a? = a+lamda (ноль или одно повторение)
  - a+ = aa* (одно или больше повторений)
- В конкретных системах могут встречаться синонимы для групп алфавитных символов, например:
  - [[:digit:]] = (0 | 1 | 2 | ...)


** Регулярные выражения в С++
#+begin_src cpp
  const std::regex r1("(c(a|b)*ab)*ca"); // | вместо +
  std::cmatch m;
  bool res1 = std::regex_match ("caabca", m, r1); // Задача принадлежности
#+end_src


** Конечные автоматы: ДКА
- Детерменированным конечным автоматом (ДКА) называется набор состояний и функция перехода между состояниями
- Некоторые состояния называют принимающими
- Ровно одно состояние является стартовым


** От регулярных выражений к автоматам
- Основаная проблема сматчить выражение вроде (a+b)*b(b+c)* это недетерменизм в том когда заканчивать матчинг первого замыкания
- Что если мы разрешим в конечных автоматах недетермнированные переходы? Например сразу в два состояния по символу?


** Конечные автоматы: НКА
- Есть два способа разрешить НКА
- Первый способ это разрешить неоднозначность в переходной функции напрямую
- Второй способ это разрешить спонтанные (эпсилон) переходы
- В любом случае можно доказать что всегда можно построить НКА из регулярного выражения
- Но кажется от НКА мало проку для программиста...


** От НКА к ДКА
- К счастью всегда можно перейти от недерминированного к детерминированному конечному автомату
- Алгоритм называется алгоритмом Рабина-Скота или конструкцией подмножеств и довольно интересен (но явно не укладывается в эту лекцию)
- Увы, такой переход может привести к экспоненциальному росту числа состояний автомата
- Для того чтобы минимизировать число состояний конечного автомата тоже есть масса довольно сложных и интересных алогоритмов
- Очень хорошо, что std::regex делает все это за нас. Проблема в том, что она делает это при каждом запуске




* Генерация лексеров
** Задача лексического анализа
- Лексический анализ это переход от текстового ввода к потоку лексем
#+begin_src cpp
  a = 0; b = 1; n = ?;
#+end_src
| VAR | ASSIGN | CST | EXPR | VAR | ASSIGN | CST | EXPR | VAR |
| a   |        |   0 |      | b   |        |   1 |      | n   |
- Позволяет рано выявить лексические ошибки и очистить задачу от мусора для более сложного синтаксического анализа


** Обсуждение 
- Можем ли мы использовать регулярные выражения для лексического анализа?
- Можем, но такое чувство, что это будет одно гигантское регулярное выражение изо всех возможных вариантов лексем
- Мы должны начать с этого регулярного выражения, дальше сделать из него НКА, далее сделать из него ДКА, далее мнимизировать ДКА
- Это лучше автоматизировать и сделать один раз где-нибудь до компиляции программы


** FLEX
- Язык и система генерации лексических анализаторов для С++. Выходом flex является класс yyFlexLexer на C++ с интерфейсом анализа
#+begin_src flex
%{
  // сюда можно вставить любые определения до паттернов
%}
// здесь дополнительные имена для регексов
%%
pattern { /* action */ }
%%
// здесь любой код после паттернов
#+end_src




* Лемма о накачке
** Обсуждение 
- Увы, не все языки являются регулярными
- Лемма о накачке гласит, что для любого достаточно длинного слова w в регулярном языке найдется такая декомпозиция w = xyz, что все слова xy^nz также принадлежит этому языку
- Поэтому язык a^nb^m регулярный: вместе с An-1ABm ему принадлежат все An-1AkBm
- Но это значит, что язык AnBn не регулярный
- Также не регулярен язык всевозможных регулярных выражений
- К счастью, есть более совершенные способы описания языков




